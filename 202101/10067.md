# 通用的缓存技术

> 1.为什么要有缓存 2.本地缓存和远程缓存  
> 3.缓存策略 4.缓存常见的问题 5.总结回顾和实践  

## 从数据说起
```text
随着业务系统越来越复杂，数据量越来越大，如何正确快速的处理这些数据，完成业务，成了一个重大课题
```

### 我们把数据的使用频率和方式进行分类    
- 静态数据：一般不变，类似字典表  
- 准静态数据：变化频率很低(部门结构设置，全国行政区划数据等)  
- 中间状态数据：一些计算的可复用的中间数据(比如每日每月的报表，销售统计，配置中心本地数据)  

以上数据的特点：  
- 热数据：使用频率高
- 读写比较大：读的频率 >> 写的频率   
这些数据适合使用缓存的方式访问

缓存的目的：为了加速数据处理，让业务能更快的访问到数据。  
狭义上，我们现在说的缓存一般指在分布式系统里把缓存到内存的数据叫做内存缓存。  

### 缓存无处不在  
内存~ 可以看作是CPU和磁盘之间的缓存  
CPU与内存的处理速度不一致，所以出现了L1&和L2缓存  
CPU处理速度大概是GHz，内存的速度现在大概也就100M级别的吧  
网络处理，数据引擎的各种Buffer，都可以看作是缓存。  
GUI的Double Buffer(双缓冲)，是一个经典的性能优化方法  

缓存的本质：  
系统各级处理速度不匹配，导致利用空间换时间  
缓存时提升系统性能的一个简单有效的办法。  

### 缓存的加载时机
两种情况    
1. 启动全量加载 ==> 全局有效，使用简单  
2. 懒加载
   - 同步使用加载 ==>  
     - 先看缓存时否有数据，有的话直接返回，    
     - 没有的话就要继续从数据库读取，然后放到内存，最后再返回给调用方。  
   - 延迟异步加载 ==>  
     - 从缓存获取数据，不管是否为空，直接返回 ==>   
       - 策略1：异步) 如果为空，则发起一个异步加载的线程，负责加载数据  
       - 策略2：解耦) 异步线程负责维护缓存的数据，定期或根据条件触发更新  
### 缓存的有效性与数据同步
1.为什么一般说变动频率大、一致性要求高的数据，不太适合用缓存？  
变化大，意味着 内存缓存数据<-->原始数据库数据，一直有差异;  
一致性要求高，意味着 只有使用原始数据，甚至加了事务，才是保险的。  

2.如何评价缓存的有效性？  
读写比：对数据的写操作导致数据变动，意味着维护成本。(N:1 这个N时多少比较合适，一般看库的压力，经验时达到3000~5000+，就需要使用缓存了)  
命中率：命中缓存意味着缓存数据被使用，意味着价值。(90%+这个程度一般才有价值)  
(--)计算机科学只存在两个难题：缓存失效和命名  
对于 数据一致性，性能，成本 的综合衡量，是引入缓存的必须指标。  
### 缓存使用不当导致的问题 
1. 系统预热导致启动慢  
    - 系统不能做到快速应对故障宕机等问题。  
2. 系统内存资源耗尽(类似于OOM)  
    - 只加入数据，不能清理旧数据。  
    - 旧数据处理不及时，或者不能有效识别无用数据。  

## 本地缓存
### 最简单的本地缓存
```java
public static final Map<String, Object> CACHE = new HashMap();
CACHE.put("shanghai", "021");

String cityPhone = (String) CACHE.get("shanghai");
```
Map的一个应用就是充当全局变量作为缓存  
思考：如何改进？还缺什么?  
比如 1.无限往内存中放数据，可能导致内存被撑爆  
    2.Hash Map并发不安全等等 
### ORM框架(Hiberate/Mybatis)中的多级缓存  
底层都是通过Ehcache实现缓存
### Guava Cache

### Spring Cache
1.基于注解和AOP，使用非常方便  
2.可以配置Condition和SPEL，非常灵活  
3.需要注意：绕过Spring的话，注解无效  
   
核心功能：@Cacheable, @CachePut, @CacheEvict  
参考：`https://developer.ibm.com/zh/articles/os-cn-spring-cache/`

### 本地缓存的缺点
1.在多个集群环境同步？当集群规模增大，缓存的读写增大；   
2.在JVM长期占用内存？如果是堆内存，能扫描到但是无法GC，总是会影响GC；     
3.缓存数据的调度处理，影响执行业务的过程，抢资源。   

由此产生 ==> 集中处理缓存  
这个集中处理缓存有什么缺点呢？  

## 远程缓存 
> 推荐一本书《Redis设计与实现》  

1.远程缓存最具代表性的就是Redis和Memcached  
2.内存网格 Hazelcast/Ignite  

## 缓存策略 
> 有多个模块，这里主要讲讲两部分：容量 和 过期策略 

### 容量
资源有限  
- 缓存数据容量是必须要考虑的问题  
- 思考系统的设计容量、使用容量、峰值，应该是我们做架构设计的一个常识  

### 过期策略
- 按FIFO或LRU
- 按固定时间过期
- 按业务时间加权：例如3+5x  
例如，机票，通常最近几天的机票，被搜索的频率是最高的，  
我们把当天的机票，缓存三分钟，往后一天加5分钟，再往后一天再加五分钟，以此类推。  

## 缓存常见问题
> 缓存常见的三大问题：穿透，击穿，雪崩

### 缓存穿透 
问题描述：大量并发查询不存在的KEY，导致直接将压力透传到数据库。  
分析：为什么会多次透传呢？不存在，一直为空。  
需要注意让缓存能够区分KEY不存在和查询到一个空值。  
解决办法：  
1.缓存空值的KEY，这样第一次不存在也会被加载被记录，下次再拿就有对应的KEY了。  
2.Bloom过滤 或 RoaringBitMap，判断KEY是否存在。  
  RoaringBitMap占用的内存比Bloom多，但是更加准确。  
3.完全以缓存为准，使用 延迟异步加载 的策略2，这样就不会触发更新。  
  这个主要的使用场景可以是防止爬虫，在识别出爬虫后，直接返回这些缓存中的数据，  
  还有正常场景，不太要求实时性的也是可以使用的  
  把 缓存的更新和处理，跟缓存的读取和使用，完全隔离掉，  
  这个和DDD中的CQRS查询和更新分离，的思想是一致的。  
  
### 缓存击穿
问题描述：某个KEY失效的时候，正好有大量并发请求访问这个KEY。  
分析：跟·缓存击穿·很像，属于比较偶然的。  
解决办法：  
1.KEY的更新操作添加全局互斥锁。  
2.完全以缓存为准，使用 延迟异步加载 的策略2，这样就不会触发更新。  

### 缓存雪崩 
问题描述：当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到DB，导致DB压力过大甚至宕机。    
分析：一般来说，由于更新策略、或者数据热点、缓存服务宕机等原因，可能会导致缓存数据同一时间点大规模不可用，或者都更新。  
    所以需要我们的更新策略要在时间上合适，数据要均匀分散，缓存服务器要多台高可用。  
解决办法：  
1.更新策略在时间上做到比较均匀。  
2.使用的热数据尽量分散到不同的机器上。  
3.多台机器做主从复制或者多副本，实现高可用。  
4.实现熔断限流机制，对系统进行负载能力空值。   
