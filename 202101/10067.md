# 通用的缓存技术

> 1.为什么要有缓存 2.本地缓存和远程缓存  
> 3.缓存策略 4.缓存常见的问题 5.总结回顾和实践  

## 从数据说起
```text
随着业务系统越来越复杂，数据量越来越大，如何正确快速的处理这些数据，完成业务，成了一个重大课题
```

### 我们把数据的使用频率和方式进行分类    
- 静态数据：一般不变，类似字典表  
- 准静态数据：变化频率很低(部门结构设置，全国行政区划数据等)  
- 中间状态数据：一些计算的可复用的中间数据(比如每日每月的报表，销售统计，配置中心本地数据)  

以上数据的特点：  
- 热数据：使用频率高
- 读写比较大：读的频率 >> 写的频率   
这些数据适合使用缓存的方式访问

缓存的目的：为了加速数据处理，让业务能更快的访问到数据。  
狭义上，我们现在说的缓存一般指在分布式系统里把缓存到内存的数据叫做内存缓存。  

### 缓存无处不在  
内存~ 可以看作是CPU和磁盘之间的缓存  
CPU与内存的处理速度不一致，所以出现了L1&和L2缓存  
CPU处理速度大概是GHz，内存的速度现在大概也就100M级别的吧  
网络处理，数据引擎的各种Buffer，都可以看作是缓存。  
GUI的Double Buffer(双缓冲)，是一个经典的性能优化方法  

缓存的本质：  
系统各级处理速度不匹配，导致利用空间换时间  
缓存时提升系统性能的一个简单有效的办法。  

### 缓存的加载时机
两种情况    
1. 启动全量加载 ==> 全局有效，使用简单  
2. 懒加载
   - 同步使用加载 ==>  
     - 先看缓存时否有数据，有的话直接返回，    
     - 没有的话就要继续从数据库读取，然后放到内存，最后再返回给调用方。  
   - 延迟异步加载 ==>  
     - 从缓存获取数据，不管是否为空，直接返回 ==>   
       - 策略1：异步) 如果为空，则发起一个异步加载的线程，负责加载数据  
       - 策略2：解耦) 异步线程负责维护缓存的数据，定期或根据条件触发更新  
### 缓存的有效性与数据同步
1.为什么一般说变动频率大、一致性要求高的数据，不太适合用缓存？  
变化大，意味着 内存缓存数据<-->原始数据库数据，一直有差异;  
一致性要求高，意味着 只有使用原始数据，甚至加了事务，才是保险的。  

2.如何评价缓存的有效性？  
读写比：对数据的写操作导致数据变动，意味着维护成本。(N:1 这个N时多少比较合适，一般看库的压力，经验时达到3000~5000+，就需要使用缓存了)  
命中率：命中缓存意味着缓存数据被使用，意味着价值。(90%+这个程度一般才有价值)  
(--)计算机科学只存在两个难题：缓存失效和命名  
对于 数据一致性，性能，成本 的综合衡量，是引入缓存的必须指标。  
### 缓存使用不当导致的问题 
1. 系统预热导致启动慢  
    - 系统不能做到快速应对故障宕机等问题。  
2. 系统内存资源耗尽(类似于OOM)  
    - 只加入数据，不能清理旧数据。  
    - 旧数据处理不及时，或者不能有效识别无用数据。  

## 本地缓存
### 最简单的本地缓存
```java
public static final Map<String, Object> CACHE = new HashMap();
CACHE.put("shanghai", "021");

String cityPhone = (String) CACHE.get("shanghai");
```
Map的一个应用就是充当全局变量作为缓存  
思考：如何改进？还缺什么?
### ORM框架(Hiberate/Mybatis)中的多级缓存  
底层都是通过Ehcache实现缓存
### Guava Cache

### Spring Cache
1.基于注解和AOP，使用非常方便  
2.可以配置Condition和SPEL，非常灵活  
3.需要注意：绕过Spring的话，注解无效  
   
核心功能：@Cacheable, @CachePut, @CacheEvict  

### 本地缓存的缺点
1.在多个集群环境同步？当规模增大，缓存的读写增大；   
2.在JVM长期占用内存？如果是堆内存，总是会影响GC；     
3.缓存数据的调度处理，影响执行业务的过程，抢资源。   

由此产生 ==> 集中处理缓存  
这个集中处理缓存有什么缺点呢？  

## 远程缓存 
